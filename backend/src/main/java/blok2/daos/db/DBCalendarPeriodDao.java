package blok2.daos.db;

import blok2.daos.ICalendarPeriodDao;
import blok2.helpers.LocationStatus;
import blok2.helpers.Pair;
import blok2.helpers.Resources;
import blok2.model.calendar.CalendarPeriod;
import blok2.model.calendar.Timeslot;
import blok2.model.reservables.Location;
import org.springframework.security.core.parameters.P;
import org.springframework.stereotype.Service;
import org.threeten.extra.YearWeek;

import java.sql.*;
import java.sql.Date;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;
import java.util.stream.Collectors;

@Service
public class DBCalendarPeriodDao extends DAO implements ICalendarPeriodDao {


    private final Logger logger = Logger.getLogger(DBCalendarPeriodDao.class.getSimpleName());

    @Override
    public List<CalendarPeriod> getCalendarPeriodsOfLocation(int locationId) throws SQLException {
        try (Connection conn = adb.getConnection()) {
            PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("get_calendar_periods_by_location"));
            pstmt.setInt(1, locationId);
            return getCalendarPeriodsFromPstmt(pstmt, conn);
        }
    }

    @Override
    public List<CalendarPeriod> getAllCalendarPeriods() throws SQLException {
        try (Connection conn = adb.getConnection()) {
            PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("get_all_calendar_periods"));
            return getCalendarPeriodsFromPstmt(pstmt, conn);
        }
    }

    public List<CalendarPeriod> getCalendarPeriodsInWeek(YearWeek week) throws SQLException {
        return getCalendarPeriodsInWeek(week.getYear(), week.getWeek());
    }
    public List<CalendarPeriod> getCalendarPeriodsInWeek(int isoyear, int isoweek) throws SQLException {
        try (Connection conn = adb.getConnection()) {
            PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("get_all_calendar_periods_in_week"));
            pstmt.setInt(1, isoyear);
            pstmt.setInt(2, isoweek);
            return getCalendarPeriodsFromPstmt(pstmt, conn);
        }
    }

    @Override
    public List<CalendarPeriod> addCalendarPeriods(List<CalendarPeriod> periods) throws SQLException {
        try (Connection conn = adb.getConnection()) {
            try {
                conn.setAutoCommit(false);

                List<CalendarPeriod> calendarPeriods = new ArrayList<>();
                for (CalendarPeriod c : periods) {
                    CalendarPeriod period = addCalendarPeriod(c, conn);
                    calendarPeriods.add(period);
                }


                conn.commit();
                return calendarPeriods;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        }
    }

    public Timeslot getTimeslot(int calendarid, int timeslotSeqNr) throws SQLException {
        try (Connection conn = adb.getConnection()) {
            PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("get_timeslot_by_id"));
            pstmt.setInt(1, calendarid);
            pstmt.setInt(2, timeslotSeqNr);
            ResultSet rs = pstmt.executeQuery();

            if(!rs.next())
                return null;

            return createTimeslot(rs, conn);

        } catch (SQLException throwables) {
            throwables.printStackTrace();
            throw throwables;
        }
    }

    public List<Timeslot> getTimeslotsByCalendarPeriod(CalendarPeriod p) throws SQLException {
        try(Connection conn = adb.getConnection()) {
            PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("get_timeslots"));
            pstmt.setInt(1, p.getId());
            ResultSet rs = pstmt.executeQuery();

            List<Timeslot> periods = new ArrayList<>();

            while (rs.next()) {
                periods.add(createTimeslot(p, rs, conn));
            }

            return periods;
        }
    }

    private CalendarPeriod addCalendarPeriod(CalendarPeriod calendarPeriod, Connection conn) throws SQLException {

        String[] generatedColumns = {Resources.databaseProperties.getString("calendar_period_id")};
        PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("insert_calendar_period"), generatedColumns);
        prepareCalendarPeriodPstmt(calendarPeriod, pstmt, 0);
        pstmt.execute();

        // set the id and seat count generated by the insert query
        ResultSet rs = pstmt.getGeneratedKeys();
        rs.next();
        int id = rs.getInt(1);

        // Returning a copy of the calendarperiod to preserve immutability.
        return new CalendarPeriod(id, calendarPeriod.getWeek().getYear(), calendarPeriod.getWeek().getWeek(), calendarPeriod.getParentId(),
                    calendarPeriod.getGroupId(), calendarPeriod.getReservableFrom(), calendarPeriod.isRepeated(), calendarPeriod.getLocationId());
    }

    @Override
    public List<Timeslot> addTimeslots(List<Timeslot> timeslots) throws SQLException {
        try(Connection conn = adb.getConnection()) {
            List<Timeslot> list = new ArrayList<>();
            for (Timeslot t : timeslots) {
                Timeslot timeslot = addTimeslot(t, conn);
                list.add(timeslot);
            }
            return list;
        }
    }


    @Override
    public Timeslot addTimeslot(Timeslot timeslot) throws SQLException {
        try(Connection conn = adb.getConnection()) {
           return addTimeslot(timeslot, conn);
        }
    }

    private Timeslot addTimeslot(Timeslot timeslot, Connection conn) throws SQLException {
        PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("insert_timeslots"));
        pstmt.setInt(1, timeslot.getPeriod().getId());
        pstmt.setInt(2, timeslot.getTimeslotSeqnr());
        pstmt.setInt(3, timeslot.getDayOfWeek());
        pstmt.setTime(4, Time.valueOf(timeslot.getStartTime()));
        pstmt.setTime(5, Time.valueOf(timeslot.getEndTime()));
        pstmt.setBoolean(6, timeslot.isReservable());
        pstmt.setInt(7, timeslot.getSeatCount());
        pstmt.execute();
        return timeslot;
    }


    @Override
    public void updateCalendarPeriods(List<CalendarPeriod> from, List<CalendarPeriod> to) throws SQLException {
        if (from.size() != to.size()) {
            logger.warning("Update calendar periods: from-list has different sizing as opposed to the to-list");
            return;
        }

        try (Connection conn = adb.getConnection()) {
            try {
                conn.setAutoCommit(false);

                for (int i = 0; i < from.size(); i++) {
                    updateCalendarPeriod(from.get(i).getId(), to.get(i), conn);
                }

                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        }
    }

    @Override
    public void updateCalendarPeriod(CalendarPeriod to) throws SQLException {
        try (Connection conn = adb.getConnection()) {
            try {
                conn.setAutoCommit(false);
                updateCalendarPeriod(to.getId(), to, conn);
                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        }
    }

    private void updateCalendarPeriod(int calendarId, CalendarPeriod to, Connection conn) throws SQLException {
        PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("update_calendar_period"));
        // set ...
        prepareCalendarPeriodPstmt(to, pstmt, 0);
        // where ...
        pstmt.setInt(10, calendarId);
        pstmt.execute();
    }

    @Override
    public void deleteCalendarPeriod(CalendarPeriod calendarPeriod) throws SQLException {
        try (Connection conn = adb.getConnection()) {
            PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("delete_calendar_period"));
            pstmt.setInt(1, calendarPeriod.getId());
            pstmt.execute();
        }
    }

    public void prepareCalendarPeriodPstmt(CalendarPeriod calendarPeriod, PreparedStatement pstmt, int offset) throws SQLException {
        pstmt.setInt(offset + 1, calendarPeriod.getWeek().getYear());
        pstmt.setInt(offset + 2, calendarPeriod.getWeek().getWeek());
        if(calendarPeriod.getParentId() == null)
            pstmt.setNull(offset + 3, Types.INTEGER);
        else
            pstmt.setInt(offset + 3, calendarPeriod.getParentId());
        pstmt.setInt(offset + 4, calendarPeriod.getGroupId());
        pstmt.setTimestamp(offset + 5, Timestamp.valueOf(calendarPeriod.getReservableFrom()));
        pstmt.setBoolean(offset + 6, calendarPeriod.isRepeated());
        pstmt.setInt(offset + 7, calendarPeriod.getLocationId());
    }


    public static Timeslot getCurrentTimeslot(int locationId, Connection conn) throws SQLException {
        PreparedStatement pstmt = conn.prepareStatement(Resources.databaseProperties.getString("get_current_and_or_next_timeslot"));
        pstmt.setInt(1, locationId);
        ResultSet rs = pstmt.executeQuery();

        if (!rs.next()) {
            return null;
        }

        return createTimeslot(rs, conn);
    }

    public CalendarPeriod getById(int calendarId) throws SQLException {
        try (Connection conn = adb.getConnection()) {
            PreparedStatement statement = conn.prepareStatement(Resources.databaseProperties.getString("get_calendar_period_by_id"));
            statement.setInt(1, calendarId);
            ResultSet set = statement.executeQuery();
            set.next();
            return createCalendarPeriod(set, conn);
        }
    }

    public static CalendarPeriod createCalendarPeriod(ResultSet rs, Connection conn) throws SQLException {
        int id = rs.getInt(Resources.databaseProperties.getString("calendar_period_id"));
        int locationId = rs.getInt(Resources.databaseProperties.getString("calendar_period_location_id"));
        LocalDateTime reservableFrom = rs.getTimestamp(Resources.databaseProperties.getString("calendar_period_reservable_from")).toLocalDateTime();
        boolean repeatPeriod = rs.getBoolean(Resources.databaseProperties.getString("calendar_period_repeat_period"));
        int groupId = rs.getInt(Resources.databaseProperties.getString("calendar_period_group_number"));
        int parentId = rs.getInt(Resources.databaseProperties.getString("calendar_period_parent_id"));
        int isoweek = rs.getInt(Resources.databaseProperties.getString("calendar_period_isoweek"));
        int isoyear = rs.getInt(Resources.databaseProperties.getString("calendar_period_isoyear"));

        return new CalendarPeriod(id, isoyear, isoweek, parentId,
                groupId, reservableFrom, repeatPeriod, locationId);
    }

    public static Timeslot createTimeslot(ResultSet rs, Connection conn) throws SQLException {
        CalendarPeriod period = createCalendarPeriod(rs, conn);
        return createTimeslot(period, rs, conn);
    }

    private static Timeslot createTimeslot(CalendarPeriod period, ResultSet rs, Connection conn) throws SQLException {
        int seqnr = (rs.getInt(Resources.databaseProperties.getString("timeslot_sequence_number")));
        int isodayOfWeek = (rs.getInt(Resources.databaseProperties.getString("timeslot_isoday_of_week")));
        boolean reservable = (rs.getBoolean(Resources.databaseProperties.getString("timeslot_reservable")));
        int count = rs.getInt(Resources.databaseProperties.getString("timeslot_reservation_count"));
        int seatCount = rs.getInt(Resources.databaseProperties.getString("timeslot_seat_count"));
        LocalTime startTime = rs.getTime(Resources.databaseProperties.getString("timeslot_start_time")).toLocalTime();
        LocalTime endTime = rs.getTime(Resources.databaseProperties.getString("timeslot_end_time")).toLocalTime();

        return new Timeslot(period, seqnr, isodayOfWeek, startTime, endTime, reservable, seatCount, count);

    }

    private List<CalendarPeriod> getCalendarPeriodsFromPstmt(PreparedStatement pstmt, Connection conn) throws SQLException {
        ResultSet rs = pstmt.executeQuery();

        List<CalendarPeriod> periods = new ArrayList<>();

        while (rs.next()) {
            periods.add(createCalendarPeriod(rs, conn));
        }

        return periods;
    }


}
